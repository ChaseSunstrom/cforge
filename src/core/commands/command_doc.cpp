/**
 * @file command_doc.cpp
 * @brief Implementation of the doc command for generating documentation with
 * Doxygen
 */

#include "cforge/log.hpp"
#include "core/commands.hpp"
#include "core/types.h"
#include "core/platform.hpp"
#include "core/process_utils.hpp"
#include "core/toml_reader.hpp"

#include <filesystem>
#include <fstream>
#include <sstream>

namespace fs = std::filesystem;

namespace {

/**
 * @brief Check if Doxygen is available
 */
bool is_doxygen_available() {
  return cforge::is_command_available("doxygen", 5);
}

/**
 * @brief Find Doxygen executable
 * Uses platform-specific paths including Homebrew on macOS
 */
std::string find_doxygen() {

  // Get platform-specific doxygen paths from platform.hpp
  auto paths = cforge::platform::get_doxygen_paths();

  // Also try just "doxygen" in PATH
  if (cforge::is_command_available("doxygen", 5)) {
    return "doxygen";
  }

  for (const auto &path : paths) {
    if (fs::exists(path)) {
      return path;
    }
  }

  // Fallback to just the command name
  return "doxygen";
}

/**
 * @brief Generate a default Doxyfile
 */
bool generate_doxyfile(const fs::path &project_dir,
                       const std::string &project_name,
                       const std::string &version,
                       const std::string &output_dir) {
  fs::path doxyfile_path = project_dir / "Doxyfile";

  std::ofstream doxyfile(doxyfile_path);
  if (!doxyfile) {
    return false;
  }

  doxyfile << "# Doxyfile generated by cforge\n\n";
  doxyfile << "PROJECT_NAME           = \"" << project_name << "\"\n";
  doxyfile << "PROJECT_NUMBER         = " << version << "\n";
  doxyfile << "PROJECT_BRIEF          = \"\"\n";
  doxyfile << "OUTPUT_DIRECTORY       = " << output_dir << "\n";
  doxyfile << "\n";
  doxyfile << "# Input settings\n";
  doxyfile << "INPUT                  = src include\n";
  doxyfile << "RECURSIVE              = YES\n";
  doxyfile << "FILE_PATTERNS          = *.cpp *.hpp *.c *.h *.cxx *.hxx *.cc\n";
  doxyfile << "\n";
  doxyfile << "# Extract settings\n";
  doxyfile << "EXTRACT_ALL            = YES\n";
  doxyfile << "EXTRACT_PRIVATE        = YES\n";
  doxyfile << "EXTRACT_STATIC         = YES\n";
  doxyfile << "\n";
  doxyfile << "# Source browser\n";
  doxyfile << "SOURCE_BROWSER         = YES\n";
  doxyfile << "INLINE_SOURCES         = NO\n";
  doxyfile << "\n";
  doxyfile << "# Output formats\n";
  doxyfile << "GENERATE_HTML          = YES\n";
  doxyfile << "GENERATE_LATEX         = NO\n";
  doxyfile << "HTML_OUTPUT            = html\n";
  doxyfile << "\n";
  doxyfile << "# Graphs (requires Graphviz)\n";
  doxyfile << "HAVE_DOT               = NO\n";
  doxyfile << "CALL_GRAPH             = NO\n";
  doxyfile << "CALLER_GRAPH           = NO\n";
  doxyfile << "\n";
  doxyfile << "# Warnings\n";
  doxyfile << "QUIET                  = YES\n";
  doxyfile << "WARNINGS               = YES\n";
  doxyfile << "WARN_IF_UNDOCUMENTED   = NO\n";
  doxyfile << "WARN_IF_DOC_ERROR      = YES\n";

  doxyfile.close();
  return true;
}

} // anonymous namespace

/**
 * @brief Handle the 'doc' command for generating documentation
 */
cforge_int_t cforge_cmd_doc(const cforge_context_t *ctx) {
  fs::path project_dir = ctx->working_dir;

  // Parse arguments
  bool verbose = false;
  bool open_docs = false;
  bool generate_doxyfile_only = false;
  std::string output_dir = "docs";

  for (cforge_int_t i = 0; i < ctx->args.arg_count; i++) {
    std::string arg = ctx->args.args[i];
    if (arg == "-v" || arg == "--verbose") {
      verbose = true;
    } else if (arg == "--open") {
      open_docs = true;
    } else if (arg == "--init") {
      generate_doxyfile_only = true;
    } else if ((arg == "-o" || arg == "--output") &&
               i + 1 < ctx->args.arg_count) {
      output_dir = ctx->args.args[++i];
    }
  }

  // Check for cforge.toml
  fs::path config_file = project_dir / "cforge.toml";
  if (!fs::exists(config_file)) {
    cforge::logger::print_error("No cforge.toml found in current directory");
    return 1;
  }

  // Load project config
  cforge::toml_reader reader;
  reader.load(config_file.string());
  std::string project_name = reader.get_string("project.name", "Project");
  std::string version = reader.get_string("project.version", "1.0.0");

  // Check for existing Doxyfile
  fs::path doxyfile_path = project_dir / "Doxyfile";
  bool has_doxyfile = fs::exists(doxyfile_path);

  if (!has_doxyfile || generate_doxyfile_only) {
    cforge::logger::print_action("Generating", "Doxyfile");
    if (!generate_doxyfile(project_dir, project_name, version, output_dir)) {
      cforge::logger::print_error("Failed to generate Doxyfile");
      return 1;
    }
    cforge::logger::print_action("Created", "Doxyfile");

    if (generate_doxyfile_only) {
      cforge::logger::print_status(
          "Doxyfile generated. Edit it to customize documentation settings.");
      return 0;
    }
  }

  // Check if Doxygen is available
  if (!is_doxygen_available()) {
    cforge::logger::print_error("Doxygen not found. Please install Doxygen:");
    cforge::logger::print_plain("  Windows: choco install doxygen.install");
    cforge::logger::print_plain("  macOS:   brew install doxygen");
    cforge::logger::print_plain("  Linux:   sudo apt install doxygen");
    return 1;
  }

  // Create output directory
  fs::path docs_path = project_dir / output_dir;
  if (!fs::exists(docs_path)) {
    fs::create_directories(docs_path);
  }

  // Run Doxygen
  cforge::logger::print_action("Generating", "documentation with Doxygen");

  std::string doxygen_cmd = find_doxygen();
  std::vector<std::string> args = {doxyfile_path.string()};

  auto result = cforge::execute_process(
      doxygen_cmd, args, project_dir.string(),
      [verbose](const std::string &line) {
        if (verbose) {
          fmt::print("{}\n", line);
        }
      },
      [](const std::string &line) {
        if (line.find("warning") != std::string::npos) {
          cforge::logger::print_warning(line);
        } else if (line.find("error") != std::string::npos) {
          cforge::logger::print_error(line);
        }
      });

  if (result.exit_code != 0) {
    cforge::logger::print_error("Doxygen failed with exit code " +
                        std::to_string(result.exit_code));
    return 1;
  }

  fs::path html_index = docs_path / "html" / "index.html";
  if (fs::exists(html_index)) {
    cforge::logger::print_action("Generated",
                         "documentation at " + html_index.string());

    // Open in browser if requested
    if (open_docs) {
#ifdef _WIN32
      std::string open_cmd = "start \"\" \"" + html_index.string() + "\"";
#elif defined(__APPLE__)
      std::string open_cmd = "open \"" + html_index.string() + "\"";
#else
      std::string open_cmd = "xdg-open \"" + html_index.string() + "\"";
#endif
      std::system(open_cmd.c_str());
    }
  } else {
    cforge::logger::print_action("Generated", "documentation in " + docs_path.string());
  }

  return 0;
}
