use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use colored::Colorize;
use serde::{Deserialize, Serialize};

use crate::config::*;
use crate::output_utils::*;
use crate::{run_command, DEFAULT_BUILD_DIR};
use crate::project::build_project;
use crate::utils::progress_bar;


fn cmake_rel_path(abs: &Path, base: &Path) -> String {
    // Diff the paths
    let rel = pathdiff::diff_paths(abs, base)
        .unwrap_or_else(|| abs.to_path_buf());

    // Convert Windows backslashes to forward slashes for CMake
    let rel_str = rel.to_string_lossy().replace("\\", "/");

    // We’ll prefix with ${CMAKE_CURRENT_LIST_DIR} so the paths remain valid
    // even if CMake is invoked from a different directory.
    format!("${{CMAKE_CURRENT_LIST_DIR}}/{}", rel_str)
}

pub fn generate_test_cmakelists(
    config: &ProjectConfig,
    project_path: &Path
) -> Result<(), Box<dyn std::error::Error>> {
    let test_config = &config.tests;
    if let Some(false) = test_config.enabled {
        return Ok(());
    }

    let test_dir = test_config.directory.as_deref().unwrap_or("tests");
    let test_path = project_path.join(test_dir);

    if !test_path.exists() {
        fs::create_dir_all(&test_path)?;
    }

    let cmakelists_path = test_path.join("CMakeLists.txt");
    let mut cmake_content = Vec::new();

    cmake_content.push("# Generated by cforge - Test configuration".to_string());
    cmake_content.push("# Do not edit manually, it will be overwritten".to_string());
    cmake_content.push(String::new());

    cmake_content.push("# Common include directories for all tests".to_string());

    // Pull the default target’s include_dirs (if any), otherwise use ["include"]
    let default_includes = config
        .targets
        .get("default")
        .and_then(|t| t.include_dirs.clone()) // Option<Vec<String>>
        .unwrap_or_else(|| vec!["include".to_string()]); // fallback if None

    if !default_includes.is_empty() {
        let includes_str = default_includes
            .iter()
            .map(|inc| {
                // Make an absolute path from the project root
                let abs_inc = project_path.join(inc);
                // Convert to a path relative to test_path
                format!("\"${{CMAKE_CURRENT_LIST_DIR}}/{}\"", cmake_rel_path(&abs_inc, &test_path))
            })
            .collect::<Vec<_>>()
            .join(" ");
        cmake_content.push(format!("include_directories({})", includes_str));
    }
    cmake_content.push(String::new());

    // 6. Default test timeout
    let default_timeout = test_config.timeout.unwrap_or(30);
    cmake_content.push(format!("# Default test timeout: {} seconds", default_timeout));
    cmake_content.push(format!("set(DEFAULT_TEST_TIMEOUT {})", default_timeout));
    cmake_content.push(String::new());

    // 7. Default labels
    if let Some(labels) = &test_config.labels {
        if !labels.is_empty() {
            cmake_content.push("# Default test labels".to_string());
            let labels_str = labels
                .iter()
                .map(|l| format!("\"{}\"", l))
                .collect::<Vec<_>>()
                .join(" ");
            cmake_content.push(format!("set(DEFAULT_TEST_LABELS {})", labels_str));
            cmake_content.push(String::new());
        }
    }

    if let Some(executables) = &test_config.executables {
        for executable in executables {
            cmake_content.push(format!("# Test executable: {}", executable.name));

            let sources_str = executable
                .sources
                .iter()
                .map(|src| {
                    let abs_source = test_path.join(src);
                    let rel_source = cmake_rel_path(&abs_source, &test_path);
                    format!("\"${{CMAKE_CURRENT_LIST_DIR}}/{}\"", rel_source)

                    
                })
                .collect::<Vec<_>>()
                .join(" ");

            cmake_content.push(format!("add_executable({} {})", executable.name, sources_str));

            // Add includes (relative to test_path)
            if let Some(includes) = &executable.includes {
                let includes_str = includes
                    .iter()
                    .map(|inc| {
                        let abs_inc = project_path.join(inc);
                        format!("\"${{CMAKE_CURRENT_LIST_DIR}}/{}\"", cmake_rel_path(&abs_inc, &test_path))
                    })
                    .collect::<Vec<_>>()
                    .join(" ");
                cmake_content.push(format!(
                    "target_include_directories({} PRIVATE {})",
                    executable.name, includes_str
                ));
            }

            // Add definitions
            if let Some(defines) = &executable.defines {
                let defines_str = defines
                    .iter()
                    .map(|d| format!("\"{}\"", d))
                    .collect::<Vec<_>>()
                    .join(" ");
                cmake_content.push(format!(
                    "target_compile_definitions({} PRIVATE {})",
                    executable.name, defines_str
                ));
            }

            // Add libraries
            if let Some(links) = &executable.links {
                let links_str = links.join(" ");
                cmake_content.push(format!(
                    "target_link_libraries({} PRIVATE {})",
                    executable.name, links_str
                ));
            }

            // Add the test
            let args_str = match &executable.args {
                Some(args) if !args.is_empty() => format!(" {}", args.join(" ")),
                _ => String::new(),
            };
            cmake_content.push(format!(
                "add_test(NAME {} COMMAND {}{})",
                executable.name, executable.name, args_str
            ));

            // Test properties
            cmake_content.push(format!("set_tests_properties({} PROPERTIES", executable.name));
            // Timeout
            cmake_content.push(format!(
                "  TIMEOUT {}",
                executable.timeout.unwrap_or(default_timeout)
            ));

            // Labels
            if let Some(labels) = &executable.labels {
                if !labels.is_empty() {
                    let labels_str = labels.join(";");
                    cmake_content.push(format!("  LABELS \"{}\"", labels_str));
                }
            } else if let Some(labels) = &test_config.labels {
                if !labels.is_empty() {
                    let labels_str = labels.join(";");
                    cmake_content.push(format!("  LABELS \"{}\"", labels_str));
                }
            }

            cmake_content.push(")".to_string());
            cmake_content.push(String::new());
        }
    } else {
        // If no test executables were defined, give a message
        cmake_content.push("# No test executables defined in cforge.toml".to_string());
        cmake_content.push("# Define tests manually or add [[tests.executables]] in cforge.toml".to_string());
        cmake_content.push(String::new());

        // Example
        cmake_content.push("# Example of manually defined test:".to_string());
        cmake_content.push("# add_executable(example_test example_test.cpp)".to_string());
        cmake_content.push("# target_link_libraries(example_test PRIVATE ${PROJECT_NAME})".to_string());
        cmake_content.push("# add_test(NAME ExampleTest COMMAND example_test)".to_string());
        cmake_content.push("# set_tests_properties(ExampleTest PROPERTIES TIMEOUT ${DEFAULT_TEST_TIMEOUT})".to_string());
        cmake_content.push(String::new());
    }

    // 9. Write out the new file
    fs::write(&cmakelists_path, cmake_content.join("\n"))?;

    // 10. Print some feedback (assuming you have a function `is_quiet()` etc.)
    if !is_quiet() {
        print_status(&format!(
            "Generated test configuration in {}/CMakeLists.txt",
            test_dir
        ));
    }

    Ok(())
}
// Enhanced test runner function
pub fn run_tests(
    config: &ProjectConfig,
    project_path: &Path,
    config_type: Option<&str>,
    variant_name: Option<&str>,
    filter: Option<&str>,
    label: Option<&str>
) -> Result<(), Box<dyn std::error::Error>> {
    let build_dir = config.build.build_dir.as_deref().unwrap_or(DEFAULT_BUILD_DIR);
    let build_path = project_path.join(build_dir);
    let build_type = config_type.unwrap_or_else(|| config.build.default_config.as_deref().unwrap_or("Debug"));

    // Test directory
    let test_dir = config.tests.directory.as_deref().unwrap_or("tests");
    let test_path = project_path.join(test_dir);

    // Check if tests directory exists
    if !test_path.exists() {
        print_warning(&format!("No {} directory found. Skipping tests.", test_dir), None);
        return Ok(());
    }

    // Ensure the project is built
    if !build_path.exists() || !build_path.join("CMakeCache.txt").exists() {
        print_status("Project not built yet. Building first...");
        let spinner = progress_bar("Building project");

        build_project(config, project_path, config_type, variant_name, None, None)?;

        spinner.success();
    }

    // Build ctest command
    let mut cmd = vec!["ctest".to_string(), "--output-on-failure".to_string()];

    // Add build configuration
    cmd.push("-C".to_string());
    cmd.push(build_type.to_string());

    // Add filter if specified
    if let Some(f) = filter {
        cmd.push("-R".to_string());
        cmd.push(f.to_string());
    }

    // Add label filter if specified
    if let Some(l) = label {
        cmd.push("-L".to_string());
        cmd.push(l.to_string());
    }

    // Add verbose flag if needed
    if !is_quiet() {
        cmd.push("-V".to_string());
    }

    // Run tests
    print_status("Running tests...");
    let spinner = progress_bar("Running tests");

    let result = run_command(cmd, Some(&build_path.to_string_lossy().to_string()), None);

    match result {
        Ok(_) => {
            spinner.success();
            print_status("All tests passed!");
            Ok(())
        },
        Err(e) => {
            spinner.failure(&e.to_string());
            print_warning("Some tests failed. Check the output for details.", None);
            Err("Some tests failed.".into())
        }
    }
}

// Generate test reports in various formats
pub fn generate_test_reports(
    config: &ProjectConfig,
    project_path: &Path,
    config_type: Option<&str>,
    format: Option<&str> // "xml", "json", etc.
) -> Result<(), Box<dyn std::error::Error>> {
    let build_dir = config.build.build_dir.as_deref().unwrap_or(DEFAULT_BUILD_DIR);
    let build_path = project_path.join(build_dir);
    let build_type = config_type.unwrap_or_else(|| config.build.default_config.as_deref().unwrap_or("Debug"));

    // Create reports directory
    let reports_dir = build_path.join("reports");
    fs::create_dir_all(&reports_dir)?;

    // Determine report format
    let report_format = format.unwrap_or("xml");

    // Build ctest command with report generation
    let mut cmd = vec![
        "ctest".to_string(),
        "--output-on-failure".to_string(),
        "-C".to_string(),
        build_type.to_string()
    ];

    match report_format.to_lowercase().as_str() {
        "xml" => {
            cmd.push("-T".to_string());
            cmd.push("Test".to_string());
            cmd.push("--no-compress-output".to_string());
        },
        "json" => {
            cmd.push("--json-output-file".to_string());
            cmd.push(reports_dir.join("test_results.json").to_string_lossy().to_string());
        },
        _ => {
            return Err(format!("Unsupported report format: {}", report_format).into());
        }
    }

    // Run tests with reporting
    print_status(&format!("Running tests and generating {} report...", report_format));
    let spinner = progress_bar("Running tests");

    let result = run_command(cmd, Some(&build_path.to_string_lossy().to_string()), None);

    match result {
        Ok(_) => {
            spinner.success();

            // For XML reports, we need to copy the Test.xml file to our reports directory
            if report_format == "xml" {
                let test_xml_path = build_path.join("Testing");

                // Find the latest test run directory
                let latest_tag_file = test_xml_path.join("TAG");
                if latest_tag_file.exists() {
                    let tag_content = fs::read_to_string(latest_tag_file)?;
                    let tag_lines: Vec<&str> = tag_content.lines().collect();

                    if !tag_lines.is_empty() {
                        let latest_dir = tag_lines[0];
                        let xml_path = test_xml_path.join(latest_dir).join("Test.xml");

                        if xml_path.exists() {
                            fs::copy(&xml_path, reports_dir.join("test_results.xml"))?;
                        }
                    }
                }
            }

            print_status(&format!("Test reports generated in {}/reports", build_dir));
            Ok(())
        },
        Err(e) => {
            spinner.failure(&e.to_string());
            print_warning("Tests failed. Reports may be incomplete.", None);
            Err("Tests failed.".into())
        }
    }
}

// Function to auto-discover tests (scan test directory for potential test files)
pub fn discover_tests(config: &ProjectConfig, project_path: &Path) -> Result<Vec<TestExecutable>, Box<dyn std::error::Error>> {
    let test_dir = project_path.join("tests");
    if !test_dir.exists() {
        return Ok(Vec::new());
    }

    let mut discovered_tests = Vec::new();

    // Find all .cpp files in the tests directory
    let entries = fs::read_dir(test_dir)?;

    for entry in entries.filter_map(Result::ok) {
        let path = entry.path();

        if path.is_file() &&
            path.extension().map_or(false, |ext| ext == "cpp" || ext == "cc" || ext == "c") {

            // Extract the filename without extension
            if let Some(filename) = path.file_stem() {
                let filename_str = filename.to_string_lossy().to_string();

                // Skip files that don't look like test files
                if !filename_str.starts_with("test_") && !filename_str.ends_with("_test") {
                    continue;
                }

                // Create a test executable for each file
                let rel_path = pathdiff::diff_paths(&path, project_path)
                    .unwrap_or_else(|| path.clone())
                    .to_string_lossy()
                    .to_string();

                let test_exec = TestExecutable {
                    name: filename_str.clone(),
                    sources: vec![rel_path],
                    includes: Some(vec!["include".to_string(), "tests".to_string()]),
                    links: Some(vec![config.project.name.clone()]),
                    defines: None,
                    args: None,
                    timeout: None,
                    labels: None,
                };

                discovered_tests.push(test_exec);
            }
        }
    }

    Ok(discovered_tests)
}

// Update the project's cforge.toml with discovered tests
pub fn update_config_with_tests(
    config: &mut ProjectConfig,
    discovered_tests: Vec<TestExecutable>
) -> Result<(), Box<dyn std::error::Error>> {
    // Only update if no tests are currently defined
    if config.tests.executables.is_none() || config.tests.executables.as_ref().unwrap().is_empty() {
        config.tests.executables = Some(discovered_tests);

        // Set default test configuration if not already set
        if config.tests.directory.is_none() {
            config.tests.directory = Some("tests".to_string());
        }

        if config.tests.enabled.is_none() {
            config.tests.enabled = Some(true);
        }

        if config.tests.timeout.is_none() {
            config.tests.timeout = Some(30);
        }

        if config.tests.labels.is_none() {
            config.tests.labels = Some(vec!["unit".to_string()]);
        }
    }

    Ok(())
}

// Initialize test directory with a sample test
pub fn init_test_directory(config: &ProjectConfig, project_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let test_dir = config.tests.directory.as_deref().unwrap_or("tests");
    let test_path = project_path.join(test_dir);

    // Create test directory if it doesn't exist
    if !test_path.exists() {
        fs::create_dir_all(&test_path)?;
    }

    // Create a sample test file
    let sample_test_path = test_path.join("test_sample.cpp");

    if !sample_test_path.exists() {
        let sample_test_content = format!(r#"#include <iostream>
#include <cassert>

// Include project headers here
// #include "../include/your_header.h"

// Simple test function
void test_sample_function() {{
    // Replace with actual test code
    int expected = 2;
    int actual = 1 + 1;
    assert(actual == expected);
    std::cout << "Sample test passed!" << std::endl;
}}

int main(int argc, char* argv[]) {{
    std::cout << "Running tests for {}" << std::endl;

    // Run tests
    test_sample_function();

    std::cout << "All tests passed!" << std::endl;
    return 0;
}}
"#, config.project.name);

        fs::write(sample_test_path, sample_test_content)?;

        if !is_quiet() {
            print_status(&format!("Created sample test in {}/test_sample.cpp", test_dir));
        }
    }

    Ok(())
}

pub fn test_workspace(
    project: Option<String>,
    config_type: Option<&str>,
    variant: Option<&str>,
    filter: Option<&str>,
    label: Option<&str>
) -> Result<(), Box<dyn std::error::Error>> {
    print_header("Workspace Tests", None);

    let workspace_config = load_workspace_config()?;

    // Determine which projects to test
    let projects = match project {
        Some(proj) => {
            print_status(&format!("Testing specific project: {}", format_project_name(&proj)));
            vec![proj]
        },
        None => {
            print_status("Testing all workspace projects");
            workspace_config.workspace.projects
        }
    };

    // Create task list
    let mut task_list = TaskList::new(projects.clone());
    task_list.display();

    // Run tests for each project
    let mut all_tests_passed = true;

    for (i, project_path) in projects.iter().enumerate() {
        task_list.start_task(i);

        let path = PathBuf::from(project_path);
        match load_project_config(Some(&path)) {
            Ok(config) => {
                print_status(&format!("Running tests for: {}", format_project_name(project_path)));

                // Generate test CMakeLists.txt if needed
                generate_test_cmakelists(&config, &path)?;

                // Run tests for this project
                match run_tests(&config, &path, config_type, variant, filter, label) {
                    Ok(_) => {
                        task_list.complete_task(i);
                    },
                    Err(_) => {
                        all_tests_passed = false;
                        print_warning(&format!("Tests failed for project: {}", project_path), None);
                    }
                }
            },
            Err(e) => {
                print_warning(&format!("Could not load config for {}: {}", project_path, e), None);
                print_warning("Skipping project", None);
                all_tests_passed = false;
            }
        }
    }

    if all_tests_passed {
        print_success("All workspace tests passed", None);
        Ok(())
    } else {
        print_warning("Some tests failed", None);
        Err("Some tests failed".into())
    }
}

pub fn init_workspace_tests(project: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
    print_header("Initialize Workspace Tests", None);

    let workspace_config = load_workspace_config()?;

    // Determine which projects to initialize
    let projects = match project {
        Some(proj) => {
            print_status(&format!("Initializing tests for project: {}", format_project_name(&proj)));
            vec![proj]
        },
        None => {
            print_status("Initializing tests for all workspace projects");
            workspace_config.workspace.projects
        }
    };

    for project_path in projects {
        let path = PathBuf::from(&project_path);
        match load_project_config(Some(&path)) {
            Ok(config) => {
                print_status(&format!("Initializing tests for: {}", format_project_name(&project_path)));
                init_test_directory(&config, &path)?;
            },
            Err(e) => {
                print_warning(&format!("Could not load config for {}: {}", project_path, e), None);
                print_warning("Skipping project", None);
            }
        }
    }

    print_success("Test initialization complete", None);
    Ok(())
}

pub fn discover_workspace_tests(project: Option<String>) -> Result<(), Box<dyn std::error::Error>> {
    print_header("Discover Workspace Tests", None);

    let workspace_config = load_workspace_config()?;

    // Determine which projects to scan
    let projects = match project {
        Some(proj) => {
            print_status(&format!("Discovering tests for project: {}", format_project_name(&proj)));
            vec![proj]
        },
        None => {
            print_status("Discovering tests for all workspace projects");
            workspace_config.workspace.projects
        }
    };

    for project_path in projects {
        let path = PathBuf::from(&project_path);
        match load_project_config(Some(&path)) {
            Ok(mut config) => {
                print_status(&format!("Scanning for tests in: {}", format_project_name(&project_path)));

                let discovered_tests = discover_tests(&config, &path)?;

                if !discovered_tests.is_empty() {
                    print_substep(&format!("Discovered {} tests", discovered_tests.len()));
                    update_config_with_tests(&mut config, discovered_tests)?;
                    save_project_config(&config, &path)?;
                } else {
                    print_warning(&format!("No tests discovered for {}", project_path), None);
                }
            },
            Err(e) => {
                print_warning(&format!("Could not load config for {}: {}", project_path, e), None);
                print_warning("Skipping project", None);
            }
        }
    }

    print_success("Test discovery complete", None);
    Ok(())
}

pub fn generate_workspace_test_reports(
    project: Option<String>,
    config_type: Option<&str>,
    format: Option<&str>
) -> Result<(), Box<dyn std::error::Error>> {
    print_header("Generate Workspace Test Reports", None);

    let workspace_config = load_workspace_config()?;

    // Determine which projects to generate reports for
    let projects = match project {
        Some(proj) => {
            print_status(&format!("Generating test reports for project: {}", format_project_name(&proj)));
            vec![proj]
        },
        None => {
            print_status("Generating test reports for all workspace projects");
            workspace_config.workspace.projects
        }
    };

    // Create reports directory in workspace root
    let reports_dir = PathBuf::from("reports");
    fs::create_dir_all(&reports_dir)?;

    for project_path in projects {
        let path = PathBuf::from(&project_path);
        match load_project_config(Some(&path)) {
            Ok(config) => {
                print_status(&format!("Generating test report for: {}", format_project_name(&project_path)));

                match generate_test_reports(&config, &path, config_type, format) {
                    Ok(_) => {
                        // Copy project reports to workspace reports directory
                        let build_dir = config.build.build_dir.as_deref().unwrap_or(DEFAULT_BUILD_DIR);
                        let project_reports_dir = path.join(build_dir).join("reports");

                        if project_reports_dir.exists() {
                            let entries = fs::read_dir(project_reports_dir)?;

                            for entry in entries.filter_map(Result::ok) {
                                let source = entry.path();
                                let dest = reports_dir.join(format!("{}_{}", project_path, entry.file_name().to_string_lossy()));

                                fs::copy(source, dest)?;
                            }
                        }
                    },
                    Err(e) => {
                        print_warning(&format!("Failed to generate report for {}: {}", project_path, e), None);
                    }
                }
            },
            Err(e) => {
                print_warning(&format!("Could not load config for {}: {}", project_path, e), None);
                print_warning("Skipping project", None);
            }
        }
    }

    print_success(&format!("Test reports generated in {}", reports_dir.display()), None);
    Ok(())
}